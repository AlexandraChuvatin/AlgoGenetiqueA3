# -*- coding: utf-8 -*-
"""probleme_DIA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1upQbwGQ3CBKVL_wV2Vd6qeby9GGS22R9
"""

import math
import pandas as pd
import random as rd
rd.seed()

#exemple de données qui donnent une fitness de 0 pour (0.152,13,6) (pour tester la méthode qui calcule la fitness)
#donnees = {1.396: -0.16669734254088095, 1.725: 0.6901053517683201, 0.222: 0.6276517650650681, 0.874: -0.9692579478143101, 0.077: 0.7923597432131905, 0.103: 0.8702857745693675, 1.358: -0.3597831750784714, 1.841: 1.0029590050118733, 1.533: 0.23341524304494535, 0.498: 0.04204673368693262, 1.299: -0.7275987179349778, 0.743: -0.6128801302309599, 1.572: 0.2686691485671261, 0.935: -0.8190745471317887, 0.519: -0.14989878805938509, 0.843: -1.0261579788953952, 0.738: -0.6512045973531374, 0.31: 0.7182407821963096, 1.611: 0.20687954036373113, 0.903: -0.8546558981874306}
#I=list(donnees.keys())
#T=list(donnees.values())

#LECTURE DU FICHIER DE DONNEES
df=pd.read_csv('temperature_sample.csv', sep=';') #'temperature_sample_calibrate2.csv'
I=df['#i']
T=df['t']

#FONCTION DE WEIERSTRASS
def W(a,b,c,i):
  w=0
  for n in range(c+1):
      w+=(a**n)*math.cos((b**n)*math.pi*i)
  return w

#FONCTION DE FITNESS (DOIT TENDRE VERS 0)
def fitness(a,b,c):
  fit=0
  for i in range(len(I)):
    fit+=abs(T[i]-W(a,b,c,I[i]))
  return fit

#ALGO GENETIQUE QUI FAIT INTERVENIR MUTATION ET CROISEMENT
def AlgoGen(individu):
  iteration=0
  
  while iteration !=400:
    #création d'un individu muté (un des 3 paramètres est aléatoirement muté)
    rand=rd.randint(0,2)
    if rand==0:
      individu2=[round(rd.uniform(0.0001,1),4),individu[1],individu[2]]
    elif rand==1:
      individu2=[individu[0],rd.randint(1, 20),individu[2]]
    else:
      individu2=[individu[0],individu[1], rd.randint(1, 20)]

    #comparaison du muté au précédent
    if (fitness(individu2[0],individu2[1],individu2[2]) < fitness(individu[0],individu[1],individu[2])):
      individu=individu2
    else:
      individu=Croisement(individu,individu2)

    iteration=iteration+1

  return individu

#METHODE QUI REALISE DES CROISEMENTS
def Croisement(i1,i2):
  iteration=0
  
  while iteration!=1:
    #création des individus mutés (un des 3 paramètres est aléatoirement échangé)
    rand=rd.randint(0,2)
    if rand==0:
      i3=[i2[0],i1[1],i1[2]]
      i4=[i1[0],i2[1],i2[2]]
    elif rand==1:
      i3=[i1[0],i2[1],i1[2]]
      i4=[i2[0],i1[1],i2[2]]
    else:
      i3=[i1[0],i1[1],i2[2]]
      i4=[i2[0],i2[1],i1[2]]

    #on doit prendre les 2 meilleurs entre i1, i2, i3 et i4 pour les refaire muter
    f1=fitness(i1[0],i1[1],i1[2])
    f2=fitness(i2[0],i2[1],i2[2])
    f3=fitness(i3[0],i3[1],i3[2])
    f4=fitness(i4[0],i4[1],i4[2])

    datas_i=[i1,i2,i3,i4] #individus
    datas_f=[f1,f2,f3,f4] #fitness correspondantes
    select=[] #liste qui contiendra les 2 meilleurs individus

    for i in range(1,3):
      indice_min=datas_f.index(min(datas_f))
      select.append(datas_i[indice_min])
      datas_i.pop(indice_min)
      datas_f.pop(indice_min)
      
    i1=select[0]
    i2=select[1]

    iteration=iteration+1

  if fitness(i3[0],i3[1],i3[2]) < fitness(i4[0],i4[1],i4[2]):
    return i3
  else:
    return i4

#METHODE PRINCIPALE
import time
def Probleme():
  start=time.time()
  individu1=[round(rd.uniform(0.0001,1),4),rd.randint(1, 20),rd.randint(1, 20)]
  
  individu=AlgoGen(individu1)
  print("Paramètres de l'individu obtenu :")
  print('a = ', individu[0])
  print('b = ', individu[1])
  print('c = ', individu[2])
  print('\nfitness =',fitness(individu[0],individu[1],individu[2]))
  print("\nTemps d'éxecution :", round(time.time()-start, 3), "seconde(s)")


Probleme()
#%timeit Probleme()
#print('test : ', fitness(0.3528741891,15,2))